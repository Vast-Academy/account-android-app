import React, {useCallback, useEffect, useMemo, useRef, useState} from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  TouchableOpacity,
  Animated,
  Easing,
  Keyboard,
  InteractionManager,
  Platform,
  Pressable,
  FlatList,
} from 'react-native';
import {CommonActions} from '@react-navigation/native';
import {Picker} from '@react-native-picker/picker';
import Icon from 'react-native-vector-icons/Ionicons';
import {colors, spacing, fontSize, fontWeight} from '../utils/theme';
import {useToast} from '../hooks/useToast';
import {useCurrencySymbol} from '../hooks/useCurrencySymbol';
import AmountActionButton from '../components/AmountActionButton';
import {getAllAccounts} from '../services/accountsDatabase';

const ITEM_HEIGHT = 44;
const VISIBLE_ITEMS = 5;
const LIST_HEIGHT = ITEM_HEIGHT * VISIBLE_ITEMS;
const LIST_PADDING = (LIST_HEIGHT - ITEM_HEIGHT) / 2;

const AmountEntryScreen = ({route, navigation}) => {
  const {showToast} = useToast();
  const currencySymbol = useCurrencySymbol();

  const {
    mode = 'add',
    account,
    prevRouteKey,
    initialEntryDate,
  } = route?.params ?? {};

  const [amount, setAmount] = useState('');
  const [note, setNote] = useState('');
  const [entryDate, setEntryDate] = useState(
    initialEntryDate ? new Date(initialEntryDate) : new Date(),
  );
  const [scheduleApplied, setScheduleApplied] = useState(false);
  const [schedulePopupVisible, setSchedulePopupVisible] = useState(false);
  const [draftEntryDate, setDraftEntryDate] = useState(null);

  const [transferAccounts, setTransferAccounts] = useState([]);
  const [transferTargetId, setTransferTargetId] = useState(null);
  const [transferSelected, setTransferSelected] = useState(false);

  const amountInputRef = useRef(null);
  const noteInputRef = useRef(null);
  const dateListRef = useRef(null);
  const hourListRef = useRef(null);
  const minuteListRef = useRef(null);
  const keyboardInsetAnim = useRef(new Animated.Value(0)).current;
  const centerShiftAnim = useRef(new Animated.Value(0)).current;

  const isWithdrawMode = mode === 'withdraw';

  useEffect(() => {
    navigation.setOptions({headerShown: false, gestureEnabled: true});
  }, [navigation]);

  useEffect(() => {
    if (!isWithdrawMode || !account?.id) {
      return;
    }
    try {
      const accounts = getAllAccounts()
        .filter(acc => acc.id !== account.id)
        .sort((a, b) => String(a.account_name).localeCompare(String(b.account_name)));
      setTransferAccounts(accounts);
      if (accounts.length > 0) {
        setTransferTargetId(accounts[0].id);
      }
    } catch (error) {
      console.error('Failed to load transfer accounts:', error);
    }
  }, [isWithdrawMode, account?.id]);

  useEffect(() => {
    const focus = () => amountInputRef.current?.focus();
    requestAnimationFrame(focus);
    InteractionManager.runAfterInteractions(focus);
    const t1 = setTimeout(focus, 120);
    return () => clearTimeout(t1);
  }, []);

  useEffect(() => {
    const showEvent = Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow';
    const hideEvent = Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide';

    const onShow = event => {
      const height = event?.endCoordinates?.height ?? 0;
      Animated.parallel([
        Animated.timing(keyboardInsetAnim, {
          toValue: height,
          duration: 240,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: false,
        }),
        Animated.timing(centerShiftAnim, {
          toValue: -10,
          duration: 240,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
      ]).start();
    };

    const onHide = () => {
      Animated.parallel([
        Animated.timing(keyboardInsetAnim, {
          toValue: 0,
          duration: 200,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: false,
        }),
        Animated.timing(centerShiftAnim, {
          toValue: 0,
          duration: 200,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
      ]).start();
    };

    const showSub = Keyboard.addListener(showEvent, onShow);
    const hideSub = Keyboard.addListener(hideEvent, onHide);
    return () => {
      showSub.remove();
      hideSub.remove();
    };
  }, [keyboardInsetAnim, centerShiftAnim]);

  const title = useMemo(() => {
    return isWithdrawMode ? 'Withdraw / Transfer' : 'Add Amount';
  }, [isWithdrawMode]);

  const isFutureEntryDate = value => {
    if (!(value instanceof Date)) {
      return false;
    }
    return value.getTime() > Date.now();
  };

  const sendResultAndGoBack = payload => {
    if (prevRouteKey) {
      navigation.dispatch(
        CommonActions.setParams({
          params: {amountEntryResult: payload},
          source: prevRouteKey,
        }),
      );
    }
    navigation.goBack();
  };

  const handleSubmit = action => {
    const parsedAmount = parseFloat(amount);
    if (!parsedAmount || parsedAmount <= 0) {
      showToast('Please enter a valid amount.', 'error');
      return;
    }
    if (isFutureEntryDate(entryDate)) {
      showToast('Future entry not allowed.', 'error');
      return;
    }
    if (action === 'transfer' && !transferTargetId) {
      showToast('Please select a transfer account.', 'error');
      return;
    }

    sendResultAndGoBack({
      accountId: account?.id ?? null,
      mode,
      action,
      amount: String(parsedAmount),
      note,
      entryDateIso: entryDate.toISOString(),
      targetAccountId: action === 'transfer' ? transferTargetId : null,
    });
  };

  const focusAmountInput = () => {
    amountInputRef.current?.focus();
  };

  const focusNoteInput = () => {
    noteInputRef.current?.focus();
  };

  const now = new Date();
  now.setSeconds(0, 0);
  const nowHour = now.getHours();
  const nowMinute = now.getMinutes();

  const dateOptions = useMemo(() => {
    const start = new Date();
    start.setHours(0, 0, 0, 0);
    start.setDate(start.getDate() - 365);
    const totalDays = 365;
    const items = [];
    for (let i = 0; i <= totalDays; i += 1) {
      const d = new Date(start);
      d.setDate(start.getDate() + i);
      items.push(d);
    }
    return items;
  }, []);

  const isSameDate = (a, b) =>
    a.getFullYear() === b.getFullYear() &&
    a.getMonth() === b.getMonth() &&
    a.getDate() === b.getDate();

  const isSameTime = (date, hour, minute) =>
    date.getHours() === hour && date.getMinutes() === minute;

  const formatDateDisplay = value => {
    const day = String(value.getDate()).padStart(2, '0');
    const month = value.toLocaleDateString([], {month: 'short'});
    return `${day} ${month}`;
  };

  const formatTimeDisplay = value => {
    const hours = value.getHours();
    const minutes = value.getMinutes();
    const suffix = hours >= 12 ? 'pm' : 'am';
    const hour12 = hours % 12 || 12;
    return `${hour12}:${String(minutes).padStart(2, '0')}${suffix}`;
  };

  const isSameDay = (a, b) =>
    a.getFullYear() === b.getFullYear() &&
    a.getMonth() === b.getMonth() &&
    a.getDate() === b.getDate();

  const clampToNow = value => {
    if (!value) {
      return value;
    }
    const base = value.getTime() > now.getTime() ? new Date(now) : new Date(value);
    const minute = base.getMinutes();
    base.setMinutes(minute - (minute % 5), 0, 0);
    return base;
  };

  const pickerValue = draftEntryDate ?? entryDate;
  const isTodaySelected = isSameDay(pickerValue, now);

  const hourOptions = useMemo(() => {
    const maxHour = isTodaySelected ? nowHour : 23;
    const items = [];
    for (let hour = 0; hour <= maxHour; hour += 1) {
      const label = String(hour).padStart(2, '0');
      items.push({hour, label});
    }
    return items;
  }, [isTodaySelected, nowHour]);

  const minuteOptions = useMemo(() => {
    const currentHour = pickerValue.getHours();
    const isCurrentHourToday = isTodaySelected && currentHour === nowHour;
    const maxMinute = isCurrentHourToday ? nowMinute : 59;
    const items = [];
    for (let minute = 0; minute <= maxMinute; minute += 5) {
      const label = String(minute).padStart(2, '0');
      items.push({minute, label});
    }
    return items;
  }, [pickerValue, isTodaySelected, nowHour, nowMinute]);

  const findDateIndex = useCallback(
    target =>
      dateOptions.findIndex(option => isSameDate(option, target)),
    [dateOptions],
  );

  const findHourIndex = useCallback(
    hour => hourOptions.findIndex(option => option.hour === hour),
    [hourOptions],
  );

  const findMinuteIndex = useCallback(
    minute => minuteOptions.findIndex(option => option.minute === minute),
    [minuteOptions],
  );

  const scrollToIndexSafe = (ref, index) => {
    if (!ref?.current || index < 0) {
      return;
    }
    try {
      ref.current.scrollToIndex({index, animated: false});
    } catch {
      // ignore scroll errors for short lists
    }
  };

  const openSchedulePopup = () => {
    setDraftEntryDate(clampToNow(new Date(entryDate)));
    setSchedulePopupVisible(true);
    InteractionManager.runAfterInteractions(() => {
      const base = clampToNow(new Date(entryDate));
      scrollToIndexSafe(dateListRef, findDateIndex(base));
      scrollToIndexSafe(hourListRef, findHourIndex(base.getHours()));
      scrollToIndexSafe(minuteListRef, findMinuteIndex(base.getMinutes()));
    });
  };
  const closeSchedulePopup = () => setSchedulePopupVisible(false);

  const applyDateSelection = selectedDate => {
    const base = draftEntryDate ? new Date(draftEntryDate) : new Date(entryDate);
    const updated = new Date(base);
    updated.setFullYear(
      selectedDate.getFullYear(),
      selectedDate.getMonth(),
      selectedDate.getDate(),
    );
    setDraftEntryDate(clampToNow(updated));
  };

  const applyTimeSelection = (hour, minute) => {
    const base = draftEntryDate ? new Date(draftEntryDate) : new Date(entryDate);
    const updated = new Date(base);
    updated.setHours(hour, minute, 0, 0);
    setDraftEntryDate(clampToNow(updated));
  };

  const updateDraftDate = nextDate => {
    setDraftEntryDate(clampToNow(nextDate));
  };

  const handleDateScrollEnd = event => {
    const index = Math.round(event.nativeEvent.contentOffset.y / ITEM_HEIGHT);
    const next = dateOptions[index];
    if (!next) {
      return;
    }
    const base = draftEntryDate ? new Date(draftEntryDate) : new Date(entryDate);
    base.setFullYear(next.getFullYear(), next.getMonth(), next.getDate());
    updateDraftDate(base);
  };

  const handleHourScrollEnd = event => {
    const index = Math.round(event.nativeEvent.contentOffset.y / ITEM_HEIGHT);
    const option = hourOptions[index];
    if (!option) {
      return;
    }
    applyTimeSelection(option.hour, pickerValue.getMinutes());
  };

  const handleMinuteScrollEnd = event => {
    const index = Math.round(event.nativeEvent.contentOffset.y / ITEM_HEIGHT);
    const option = minuteOptions[index];
    if (!option) {
      return;
    }
    applyTimeSelection(pickerValue.getHours(), option.minute);
  };

  const handleScheduleDone = () => {
    if (draftEntryDate) {
      setEntryDate(clampToNow(new Date(draftEntryDate)));
    }
    setScheduleApplied(true);
    setSchedulePopupVisible(false);
  };

  const scheduleCtaLabel = scheduleApplied
    ? `${formatDateDisplay(entryDate)} ${formatTimeDisplay(entryDate)}`
    : 'Schedule';

  const scheduleDoneLabel = `Set at ${formatDateDisplay(pickerValue)} ${formatTimeDisplay(
    pickerValue,
  )}`;

  return (
    <Pressable style={styles.screen} onPress={Keyboard.dismiss}>
      <Animated.View
        style={[
          styles.container,
          {paddingBottom: keyboardInsetAnim},
        ]}>
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.headerButton}
            onPress={() => navigation.goBack()}>
            <Icon name="arrow-back" size={22} color={colors.text.primary} />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>{title}</Text>
          <View style={styles.headerSpacer} />
        </View>

        <Animated.View
          style={[
            styles.centerArea,
            {transform: [{translateY: centerShiftAnim}]},
          ]}>
          <Pressable style={styles.tapZone} onPress={focusAmountInput}>
            <View style={styles.amountBlock}>
              <Text style={styles.currencySymbol}>{currencySymbol}</Text>
              <TextInput
                ref={amountInputRef}
                style={styles.amountInput}
                value={amount}
                onChangeText={setAmount}
                keyboardType="numeric"
                placeholder="0"
                placeholderTextColor="#C0C4CC"
                autoFocus
                showSoftInputOnFocus
              />
            </View>
          </Pressable>
          <Pressable style={styles.tapZone} onPress={focusNoteInput}>
            <TextInput
              ref={noteInputRef}
              style={styles.noteInput}
              value={note}
              onChangeText={setNote}
              placeholder="Add note"
              placeholderTextColor={colors.text.light}
              multiline
              numberOfLines={2}
            />
          </Pressable>
          <View style={styles.centerScheduleBlock}>
            <TouchableOpacity
              style={styles.scheduleCta}
              onPress={openSchedulePopup}
              activeOpacity={0.9}>
              <Text style={styles.scheduleCtaText}>{scheduleCtaLabel}</Text>
            </TouchableOpacity>
          </View>
        </Animated.View>

        <View style={styles.bottomArea}>
          <View style={styles.panel}>
            {isWithdrawMode && transferSelected && (
              <View style={styles.transferPickerBlock}>
                <Text style={styles.transferLabel}>Transfer To</Text>
                <View style={styles.pickerContainer}>
                  <Picker
                    selectedValue={transferTargetId}
                    onValueChange={setTransferTargetId}>
                    {transferAccounts.map(acc => (
                      <Picker.Item
                        key={acc.id}
                        label={acc.account_name}
                        value={acc.id}
                      />
                    ))}
                  </Picker>
                </View>
              </View>
            )}

            {isWithdrawMode ? (
              <View style={styles.actionRow}>
                <AmountActionButton
                  label="Withdraw"
                  variant="dangerOutline"
                  style={styles.actionButton}
                  textStyle={styles.withdrawText}
                  onPress={() => handleSubmit('withdraw')}
                />
                <AmountActionButton
                  label={transferSelected ? 'Transfer Now' : 'Transfer'}
                  variant="primaryOutline"
                  style={styles.actionButton}
                  textStyle={styles.transferText}
                  onPress={() => {
                    if (!transferSelected) {
                      setTransferSelected(true);
                      return;
                    }
                    handleSubmit('transfer');
                  }}
                />
              </View>
            ) : (
              <AmountActionButton
                label="Add Amount"
                variant="successOutline"
                style={styles.singleActionButton}
                textStyle={styles.addText}
                onPress={() => handleSubmit('add')}
              />
            )}
          </View>
        </View>

        {schedulePopupVisible && (
          <Animated.View style={[styles.scheduleOverlay, {paddingBottom: keyboardInsetAnim}]}>
            <Pressable style={styles.scheduleBackdrop} onPress={closeSchedulePopup} />
            <View style={styles.schedulePanel}>
              <View style={styles.scheduleHeader}>
                <TouchableOpacity
                  onPress={closeSchedulePopup}
                  style={styles.scheduleCloseButton}>
                  <Icon name="close" size={20} color={colors.text.primary} />
                </TouchableOpacity>
              </View>

                <View style={styles.schedulePickerBox}>
                <View style={styles.schedulePickerColumn}>
                  <FlatList
                    ref={dateListRef}
                    data={dateOptions}
                    keyExtractor={item => item.toISOString()}
                    style={styles.schedulePickerList}
                    contentContainerStyle={styles.schedulePickerListContent}
                    keyboardShouldPersistTaps="handled"
                    showsVerticalScrollIndicator={false}
                    initialNumToRender={24}
                    maxToRenderPerBatch={24}
                    windowSize={7}
                    removeClippedSubviews
                    getItemLayout={(_, index) => ({
                      length: ITEM_HEIGHT,
                      offset: ITEM_HEIGHT * index,
                      index,
                    })}
                    snapToInterval={ITEM_HEIGHT}
                    decelerationRate="fast"
                    onMomentumScrollEnd={handleDateScrollEnd}
                    renderItem={({item: optionDate}) => {
                      const selected = isSameDate(pickerValue, optionDate);
                      return (
                        <Pressable
                          style={[
                            styles.inlinePickerItem,
                            selected && styles.inlinePickerItemSelected,
                          ]}
                          onPress={() => applyDateSelection(optionDate)}>
                          <Text
                            style={[
                              styles.inlinePickerItemText,
                              selected && styles.inlinePickerItemTextSelected,
                            ]}>
                            {formatDateDisplay(optionDate)}
                          </Text>
                        </Pressable>
                      );
                    }}
                  />
                </View>
                <View style={styles.schedulePickerColumn}>
                  <FlatList
                    ref={hourListRef}
                    data={hourOptions}
                    keyExtractor={item => `${item.hour}`}
                    style={styles.schedulePickerList}
                    contentContainerStyle={styles.schedulePickerListContent}
                    keyboardShouldPersistTaps="handled"
                    showsVerticalScrollIndicator={false}
                    initialNumToRender={24}
                    maxToRenderPerBatch={24}
                    windowSize={7}
                    removeClippedSubviews
                    getItemLayout={(_, index) => ({
                      length: ITEM_HEIGHT,
                      offset: ITEM_HEIGHT * index,
                      index,
                    })}
                    snapToInterval={ITEM_HEIGHT}
                    decelerationRate="fast"
                    onMomentumScrollEnd={handleHourScrollEnd}
                    renderItem={({item}) => {
                      const selected = pickerValue.getHours() === item.hour;
                      return (
                        <Pressable
                          style={[
                            styles.inlinePickerItem,
                            selected && styles.inlinePickerItemSelected,
                          ]}
                          onPress={() =>
                            applyTimeSelection(item.hour, pickerValue.getMinutes())
                          }>
                          <Text
                            style={[
                              styles.inlinePickerItemText,
                              selected && styles.inlinePickerItemTextSelected,
                            ]}>
                            {item.label}
                          </Text>
                        </Pressable>
                      );
                    }}
                  />
                </View>
                <View style={styles.schedulePickerColumn}>
                  <FlatList
                    ref={minuteListRef}
                    data={minuteOptions}
                    keyExtractor={item => `${item.minute}`}
                    style={styles.schedulePickerList}
                    contentContainerStyle={styles.schedulePickerListContent}
                    keyboardShouldPersistTaps="handled"
                    showsVerticalScrollIndicator={false}
                    initialNumToRender={24}
                    maxToRenderPerBatch={24}
                    windowSize={7}
                    removeClippedSubviews
                    getItemLayout={(_, index) => ({
                      length: ITEM_HEIGHT,
                      offset: ITEM_HEIGHT * index,
                      index,
                    })}
                    snapToInterval={ITEM_HEIGHT}
                    decelerationRate="fast"
                    onMomentumScrollEnd={handleMinuteScrollEnd}
                    renderItem={({item}) => {
                      const selected = pickerValue.getMinutes() === item.minute;
                      return (
                        <Pressable
                          style={[
                            styles.inlinePickerItem,
                            selected && styles.inlinePickerItemSelected,
                          ]}
                          onPress={() =>
                            applyTimeSelection(pickerValue.getHours(), item.minute)
                          }>
                          <Text
                            style={[
                              styles.inlinePickerItemText,
                              selected && styles.inlinePickerItemTextSelected,
                            ]}>
                            {item.label}
                          </Text>
                        </Pressable>
                      );
                    }}
                  />
                </View>
              </View>

              <AmountActionButton
                label={scheduleDoneLabel}
                variant="primaryOutline"
                style={styles.scheduleDoneButton}
                textStyle={styles.scheduleDoneText}
                onPress={handleScheduleDone}
              />
            </View>
          </Animated.View>
        )}
      </Animated.View>
    </Pressable>
  );
};

const styles = StyleSheet.create({
  screen: {
    flex: 1,
    backgroundColor: '#F8FAFC',
  },
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: spacing.lg,
    paddingTop: spacing.lg,
    paddingBottom: spacing.md,
  },
  headerButton: {
    padding: 6,
  },
  headerTitle: {
    fontSize: fontSize.large,
    fontWeight: fontWeight.bold,
    color: colors.text.primary,
  },
  headerSpacer: {
    width: 34,
  },
  centerArea: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingHorizontal: spacing.lg,
    paddingTop: spacing.xl * 3.8,
  },
  tapZone: {
    width: '100%',
    alignItems: 'center',
  },
  centerScheduleBlock: {
    width: '100%',
    marginTop: spacing.sm,
    paddingHorizontal: spacing.lg,
    alignItems: 'center',
    gap: spacing.xs,
  },
  scheduleCta: {
    paddingVertical: 10,
    paddingHorizontal: spacing.lg,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: colors.primary,
    backgroundColor: '#EFF6FF',
  },
  scheduleCtaText: {
    fontSize: fontSize.small,
    fontWeight: fontWeight.semibold,
    color: colors.primary,
  },
  amountBlock: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  currencySymbol: {
    fontSize: 28,
    color: '#9CA3AF',
    marginRight: 6,
  },
  amountInput: {
    fontSize: 48,
    fontWeight: fontWeight.bold,
    color: colors.text.primary,
    minWidth: 120,
    textAlign: 'center',
    paddingVertical: 4,
  },
  bottomArea: {
    paddingHorizontal: spacing.lg,
    paddingBottom: spacing.lg,
  },
  panel: {
    backgroundColor: colors.white,
    borderRadius: 20,
    padding: spacing.md,
    borderWidth: 1,
    borderColor: '#E5E7EB',
    shadowColor: '#0F172A',
    shadowOpacity: 0.08,
    shadowRadius: 16,
    shadowOffset: {width: 0, height: 6},
    elevation: 8,
    gap: spacing.sm,
  },
  entryDateTimeRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  entryDateTimeButton: {
    flex: 1,
    backgroundColor: colors.surface,
    borderRadius: 12,
    paddingVertical: 10,
    paddingHorizontal: spacing.sm,
    borderWidth: 1,
    borderColor: colors.border,
  },
  entryDateTimeButtonActive: {
    borderColor: colors.primary,
    backgroundColor: '#EFF6FF',
  },
  entryDateTimeLabel: {
    fontSize: fontSize.small,
    color: colors.text.secondary,
    marginBottom: 2,
  },
  entryDateTimeValue: {
    fontSize: fontSize.medium,
    fontWeight: fontWeight.semibold,
    color: colors.text.primary,
  },
  inlinePickerList: {
    marginTop: spacing.xs,
    maxHeight: 180,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: colors.border,
    backgroundColor: colors.white,
  },
  inlinePickerItem: {
    height: ITEM_HEIGHT,
    justifyContent: 'center',
    paddingHorizontal: spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: '#F1F5F9',
  },
  inlinePickerItemSelected: {
    backgroundColor: 'transparent',
  },
  inlinePickerItemText: {
    fontSize: fontSize.medium,
    color: colors.text.primary,
    fontWeight: fontWeight.semibold,
  },
  inlinePickerItemTextSelected: {
    color: colors.text.primary,
  },
  scheduleOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'flex-end',
    zIndex: 9999,
    elevation: 9999,
  },
  scheduleBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(2, 6, 23, 0.35)',
  },
  schedulePanel: {
    zIndex: 10000,
    elevation: 10000,
    backgroundColor: colors.white,
    borderBottomLeftRadius: 20,
    borderBottomRightRadius: 20,
    paddingHorizontal: spacing.lg,
    paddingTop: spacing.md,
    paddingBottom: spacing.lg,
    gap: spacing.sm,
    maxHeight: '62%',
    marginBottom: spacing.xl * 2,
  },
  scheduleHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'flex-end',
  },
  scheduleCloseButton: {
    padding: 6,
  },
  schedulePickerBox: {
    position: 'relative',
    flexDirection: 'row',
    gap: spacing.sm,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: colors.border,
    backgroundColor: colors.white,
    paddingVertical: spacing.xs,
    paddingHorizontal: spacing.xs,
    maxHeight: 260,
    overflow: 'hidden',
  },
  schedulePickerColumn: {
    flex: 1,
    zIndex: 2,
    position: 'relative',
  },
  schedulePickerList: {
    height: LIST_HEIGHT,
  },
  schedulePickerListContent: {
    paddingVertical: LIST_PADDING,
  },
  scheduleDoneButton: {
    marginTop: spacing.xs,
  },
  scheduleDoneText: {
    color: colors.primary,
  },
  transferPickerBlock: {
    gap: 6,
  },
  transferLabel: {
    fontSize: fontSize.small,
    color: colors.text.secondary,
    fontWeight: fontWeight.semibold,
  },
  pickerContainer: {
    borderWidth: 1,
    borderColor: colors.border,
    borderRadius: 12,
    overflow: 'hidden',
  },
  noteInput: {
    fontSize: fontSize.medium,
    color: colors.text.primary,
    paddingVertical: 8,
    paddingHorizontal: spacing.md,
    width: '82%',
    textAlign: 'center',
    marginTop: spacing.sm,
    minHeight: 44,
    textAlignVertical: 'center',
  },
  actionRow: {
    flexDirection: 'row',
    gap: spacing.xs,
  },
  actionButton: {
    flex: 1,
  },
  singleActionButton: {
    borderColor: '#4ADE80',
  },
  addText: {
    color: '#16A34A',
  },
  withdrawText: {
    color: '#EF4444',
  },
  transferText: {
    color: '#1D4ED8',
  },
});

export default AmountEntryScreen;

